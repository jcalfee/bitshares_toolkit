/**
@defgroup wallet_specification BitShares Wallet High-Level Specification
@brief Desired functionality and algorithms used for bitshares wallet

# Wallet Functionality

## Create a transaction cache for transactions that affect user's wallet (e.g. wallet balance)
This cache is built by scanning the blockchain and processing pending transactions (currently only processes blockchain transactions, pending transactions support needs to be added). Is there anything special that needs to be done for pending transactions? Should there be extra info in the transaction_state for them (maybe just the -1 to indicate not in a block yet).

## Compute Confirmed Balance
Transactions are considered fully confirmed if 51% of the delegates have confirmed the transaction by issuing a block that incorporates it. Currently this is computed on the fly from the transaction cache. Note: currently code considers all transactions in a block to be confirmed.

## Compute Unconfirmed Balance
Transactions that are not yet fully confirmed are kept in a separate wallet balance (one for each asset type) until they have been fully confirmed. Currently this is computed on the fly from the transaction cache (well, not actually computed at all yet, this needs to be implemented).

## Create transactions from user accounts
- Pick an appropriate set of unspent outputs to act as inputs to the transaction (see pseudocode for description of current algorithm for selecting this set).
- Transfer any overage to a �change� account. Create a new change account for each transaction and ouptut the overage to this account. This implies the user may end up holding a substantial and ever-growing number of keys (see Change addresses discussion).
- Compute any fees required for the transaction and add additional unspent outputs as inputs if required (which changes the fee required again and can in turn require additional inputs...). The minimum fee for a valid transaction is the next_fee (computed by blockchain code, see blockchain.dox for details) * transaction_size_in_bytes. See "Transaction Fee Issues" for potential problems with this approach to fee calculation for the transaction.
- If no change required (an unlikely scenario), remove the change output. Probably we should remove the key we created as well in this case.
- Randomize the ordering of the outputs //TODO
- Report if insufficient funds to perform the transaction
- Submit transaction to the p2p network

## Change addresses
We create one change address (key pair) for every transaction (regardless of whether it's used or not in the transaction). This may work acceptably for human-operated wallets, but it's not a sound strategy for anything that generates transactions in an automated fashion since too many keys will end up being created and stored. This implies we'll want to supply an rpc call that supports generating multi-output transactions and so that the rpc client application can generate it's own change addresses (and therefore re-use existing change addresses instead of having to create a new one for each transaction).

We could also potentially prune change address keys when they are "spent", as there should be no reasonable expectation of these being outputs in future transactions (only "receiving addresses" explicitly generated by the user should be expected to receive future payments).

## Transaction Fee Issues

It's possible that a wallet may compute a transaction without having seen the "latest" block (or even several blocks), in which case it's possible the fee_rate could have increased, which could lead to the wallet generating a transaction that won't be accepted by peers (if they've seen the block) or not put into the blockchain. With the current fee algorithm, the fee rate can only increase by 2% per block generated, so we can workaround this issue by paying 110% of the fee (this would allow us to miss 5 blocks all with maximum increases in the fee_rate and still generate a transaction with an acceptable fee for the network).

## Processing transactions in a block
- Check each transaction in a block to see if it affects the user's wallet.

## Process user-created pending transactions
- Process each transaction as locally confirmed (shows in confirmed balance, but transaction itself shows as unconfirmed).

## Process peer-received pending transactions
- Process each transaction as  unconfirmed (shows in unconfirmed balance and transaction shown as unconfirmed).

## Steps in processing a basic currency transaction
- If any of the inputs to the transaction are from accounts we control, decrease the wallet balance by the amount in those accounts (accounts are fully spent by a transaction and any overage is sent to a �change� account as an output of the transaction)
- If any of the outputs to the transaction are to accounts we control, increase the wallet balance by the amounts transferred to those accounts)

Vote down delegates when there is a valid transaction not getting included in the blockchain for more than one block from the time you receive it. For now we will just log this as a diagnostic aid.

## Method of canceling locally-created transactions

## Processing an invalidated transaction

## Miscellaneous information to report
- List configurable number of recent transactions
- List of pending transactions
- List of named receiving addresses (for incoming transfers)
- List of named addresses to send to (address book for outgoing transfers)
- Add number of confirmations and �delegate voted for� to transaction display
- Report the total number of transactions (confirmed and unconfirmed) that affect the user's wallet (size of transaction cache).

## Importable/Exportable information
- import/export private keys in same format as bitcoin, wallet in json (default format, but may need to unencrypt if wallet passphrase was used)

## Other features
- Sign a message
- Verify a message
- Set/Verify Wallet Passphrase (none by default)
- Set/Verify Spending Passphrase

## Transaction output claim types
- claim_by_signature_output: claim by owning a bitshares private key that matches public key referenced in the output
- claim_by_pts_output: claim by owning a PTS private key that matches public key referenced in the output (these are only used for initial genesis block allocations)
- claim_name_output: find the registered delegate public key that matches public key referenced in the output.

## Transaction Fee
The transaction fee rate is calculated in the blockchain code and stored into the previous block as "next fee". Fee is validated by all full clients, so the generating delegate can't place an arbitrarily high fee to lock up the network. This means the fee doesn't
actually have to be included in the blockchain, but it's included for now for potential use of some sort by a lightweight client or if old blocks have been discarded from the blockchain.

## Wallet GUI additional features
- Display table of all transactions sortable by different column fields


# Detailed BitShares Wallet pseudocode

transaction_state: contains effects of a single transaction on the wallet(trx field is the "input" with the broadcast transaction data). We make a transaction_state for each transaction that impacts the wallet balances and we record the changes here to each of our wallet balances (we have balances for each asset type, and we have confirmed and unconfirmed balances for each asset type).

@code

//returns a map of all the wallet transaction states (transaction_id -> transaction_state)
get_transaction_history()
  return _data.transactions map;
  
//transfer amount to an address
transfer(amount,to-address,memo)
  create transaction object and set to-address as first transaction output (a change output may also be added by next step)
  collect_inputs_and_sign(transaction,amount,memo)
  
//this creates a transaction that says you want to be considered as a delegate  
register_delegate(name,data)
  create transaction object and set transaction output to claim_name_output with a newly generated public key for delegate
  
mark_as_spent(output_reference)
  if output reference is not ours (not in output_ref_to_index map) or we've already spent it
    just ignore it //consider if we can/should assert if already spent
  else 
    remove from unspent_outputs and move to spent_outputs
  
void sign_transaction( signed_transaction& transaction, addresses, bool mark_output_as_used = true)
  sign transaction addresses and mark_as_spent the inputs if requested
  
collect_inputs_and_sign(transaction,requested_amount,required_signatures, change_address)
  required_input = requested_amount
  save off original inputs and outputs to transaction
  do
    restore original inputs and outputs to transaction (this is not efficient, but I suppose we don't care right now)
    total_input = required_amount
    new_inputs = collect_inputs(required_input, total_input, required_signatures)
    add new_inputs to transaction
    change_amount = total_input - requested_input;
    add output transaction to change_address for change_amount
    if requested transaction is not in base asset type
      return collect_inputs_and_sign again //explain why this is done in more detail
      
    sign transaction with any required_signatures (doesn't mark inputs as spent here)
    compute fee from transaction size
    required_input += fee
    if (total_input < required_input)
      continue;
    Calculate leftover change
    change_amount = total_input - required_input
  while (total_input < required_input);
  change_amount = total_input - required_fee
  if change_amount > 0
    update change output transaction with current change amount
  else
    remove change output from transaction
  clear transactions signatures
  re-sign transaction, this time marking inputs as spent
  
//Collect inputs that total to at least requested_amount.
inputs collect_inputs(requested_amount, total_input, required_signatures)
  for each unspent output
    if output contains proper asset type
      create an input using this output
      total_input += output's amount
      add this output as a required signature for the transaction
      if (total_input.get_rounded_amount() > requested_amount.get_rounded_amount())
        return inputs
  throw "insufficient funds"
        


receive_addresses: these are public keys we control that may be referenced in transaction endpoints. They have no balances until a transaction specifies an output to a receive address.

output_reference type: points to an output as (transaction_hash, output_index_in_transaction)

output_index type: points to an output as (block_number,transaction_index_in_block, output_index_in_transaction)
//For efficiency reasons, the wallet maps outputs as output_indexes. Need more description of nature of increased
efficiency (space or time saving?).

spent_outputs: this container points to transaction outputs in a transaction that have funds (outputs are unique)

unspent_outputs: this container points to transaction outputs in a transaction whose amounts have been transferred to another address (outputs are unique here)

bool scan_input(transaction_state,output,output_reference,output_index)
  if we control the input's output source(it's in our spent or unspent outputs)
    decrease delta balance of transaction by output amount (this input is our money being spent)
    return true (input affects wallet)
  else
    return false

bool scan_output(transaction_state,output,output_reference,output_index)
  if we control the output (if output's address is one of our receive addresses)
    increase delta balance of transaction by output amount (this is money being sent to us)
    add output to unspent_outputs
    return true (output affects wallet)
  else
    return false
  
bool scan_transaction(transaction_state, block_index, transaction_index)
  foreach input in the transaction
    if output in output_ref_to_index
      scan_input(...)
      mark_as_spent(output_ref) //move from unspent to spent outputs container
  for each output in the transaction
    scan_output(...)
  return true if any input or output affects addresses we control
  
scan_chain(chain_database, from_block_num, scan_progress_callback)
  foreach block starting from_block_num
    foreach transaction
      check if any callback is registered for reporting progress of scanning transactions
      fetch from chain
      found_output = scan_transaction
      if found_output 
        add new transaction state to map (effectively a set) of transactions affecting wallet
    foreach deterministic transaction
      fetch from chain
      found_output = scan_transaction
      if found_output 
        add new transaction state to map of transactions affecting wallet
  set_fee_rate(chain.get_fee_rate())
  _stake = chain.get_stake()
  _last_scanned_block_num = head_block_num
  return if a new input was found or an output was spent

//probably should cache the balances for each asset type instead
get_balance(asset_type)
  sum up the unspent_outputs for the requested asset type  

collect_mining_input (deprecated, remove?)

//generate next block from a set of pending transactions
result generate_next_block(chain_database,input_transactions)
  chain_db.generate_deterministic_transactions()  
  foreach transaction in input_transactions
    validate transaction and discard if invalid (transaction validated in isolation)
    compute fee for transaction
    if transaction fee < fee_rate * transaction size
      report enough fee wasn't paid and skip transaction
    else
      add to valid_transactions
  sort transactions with highest fees first
  foreach transaction in valid_transactions
    foreach transaction input
      if transaction in consumed_outputs
        mark transaction to be skipped
      else
        add transaction to consumed_outputs
    if transaction has no consumed_outputs
      try to add it to block (evaluted in context of already added transactions)
  calculate and return result containing: new block number, 
     a list of all accepted transactions for new block, previous block id,
     merkle root of deterministic transactions for block, fee rate for next block,
     total outstanding shares after removal of fees, and timestamp

@endcode
     
## General Notes
- Generation of transactions (transfer) could be speeded up a lot (there's a lot of potential for re-doing old work when the fees require more inputs to the transaction), but probably we don't care right now.

## Things to do (lots to be added here)
- Function to generate unconfirmed balances from pending transactions for each asset type
- Report partial confirmation of blockchain transactions
- Randomize outputs of generated transactions
- Increase fee paid for transactions to avoid transaction not getting accepted if there are one or more "unseen blocks" on network with increased fee rates.

*/
